(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{431:function(e,v,o){"use strict";o.r(v);var t=o(2),_=Object(t.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[v("strong",[e._v("vue3 比 vue2 有什么优势")]),e._v("\n性能更好，打包体积更小，更好的 ts 支持，更好的代码组织，更好的逻辑抽离，更多的新功能")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("性能优化：使用了 Proxy 替代 Object.defineProperty 实现响应式，并且使用了静态提升技术来提高渲染性能。新增了编译时优化，在编译时进行模板静态分析，并生成更高效的渲染函数。")])]),e._v(" "),v("li",[v("p",[e._v("Composition API：一个全新的组件逻辑复用方式，可以更好地组合和复用组件的逻辑。")])]),e._v(" "),v("li",[v("p",[e._v("TypeScript 支持：在编写 Vue 应用程序时可以更方便地利用 TS 的类型检查和自动补全功能。")])]),e._v(" "),v("li",[v("p",[e._v("自定义渲染 API：允许开发者在细粒度上控制组件渲染行为，包括自定义渲染器、组件事件和生命周期等。")])])]),e._v(" "),v("p",[v("strong",[e._v("生命周期")])]),e._v(" "),v("ol",[v("li",[v("p",[e._v("beforeCreate: 在实例初始化之后、数据观测(initState)和 event/watcher 事件配置之前被调用。 对于此时做的事情，如注册组件使用到的 store 或者 service 等单例的全局物件。")])]),e._v(" "),v("li",[v("p",[e._v("created: 一个新的 Vue 实例被创建后（包括组件实例），立即调用此函数。 在这里做一下初始的数据处理、异步请求等操作，当组件完成创建时就能展示这些数据。")])]),e._v(" "),v("li",[v("p",[e._v("beforeMount: 在挂载之前调用，相关的 render 函数首次被调用,在这里可以访问根节点，在执行 mounted 钩子前，dom 渲染成功。")])]),e._v(" "),v("li",[v("p",[e._v("onMounted: 在挂载后调用，也就是所有相关的 DOM 都已入图，有了相关的 DOM 环境，可以在这里执行节点的 DOM 操作。在这之前执行 beforeUpdate。")])]),e._v(" "),v("li",[v("p",[e._v("beforeUpdate: 在数据更新时同时在虚拟 DOM 重新渲染和打补丁之前调用。我们可以在这里访问先前的状态和 dom，如果我们想要在更新之前保存状态的快照，这个钩子非常有用。")])]),e._v(" "),v("li",[v("p",[e._v("onUpdated:在数据更新完毕后，虚拟 DOM 重新渲染和打补丁也完成了，DOM 已经更新完毕。这个钩子函数调用时，组件 DOM 已经被更新，可以执行操作，触发组件动画等操作")])]),e._v(" "),v("li",[v("p",[e._v("beforeUnmount:在卸载组件之前调用。在这里执行清除操作，如清除定时器、解绑全局事件等。")])]),e._v(" "),v("li",[v("p",[e._v("onUnmounted:在卸载组件之后调用，调用时，组件的 DOM 结构已经被拆卸，可以释放组件用过的资源等操作。")])]),e._v(" "),v("li",[v("p",[e._v("onActivated – 被 keep-alive 缓存的组件激活时调用。")])]),e._v(" "),v("li",[v("p",[e._v("onDeactivated – 被 keep-alive 缓存的组件停用时调用。")])]),e._v(" "),v("li",[v("p",[e._v("onErrorCaptured – 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播")])])]),e._v(" "),v("p",[v("strong",[e._v("如何看待 Composition API 和 Options API")]),e._v("\nComposition API 更好的代码组织，更好的逻辑服用；可维护性，更好的类型推导，可拓展性更好\n对于小型项目，Options API 更为简单方便；对于大型项目，Composition API 可以更好地组织代码。")]),e._v(" "),v("p",[v("strong",[e._v("Proxy 和 Object.defineProperty 的区别")])]),e._v(" "),v("ol",[v("li",[v("p",[e._v("实现方式：Proxy 是 ES6 新增的一种特性，使用了一种代理机制来实现响应式。而 Object.defineProperty 是在 ES5 中引入的，使用了 getter 和 setter 方法来实现。")])]),e._v(" "),v("li",[v("p",[e._v("作用对象：Proxy 可以代理整个对象，包括对象的所有属性、数组的所有元素以及类似数组对象的所有元素。而 Object.defineProperty 只能代理对象上定义的属性。")])]),e._v(" "),v("li",[v("p",[e._v("监听属性：Proxy 可以监听到新增属性和删除属性的操作，而 Object.defineProperty 只能监听到已经定义的属性的变化。")])])]),e._v(" "),v("p",[v("strong",[e._v("vue2 和 vue3 核心 diff 算法区别")]),e._v("\nVue 2.x 使用的是双向指针遍历的算法，也就是通过逐层比对新旧虚拟 DOM 树节点的方式来计算出更新需要做的最小操作集合。但这种算法的缺点是，由于遍历是从左到右、从上到下进行的，当发生节点删除或移动时，会导致其它节点位置的计算出现错误，因此会造成大量无效的重新渲染。\nVue 3.x 使用了经过优化的单向遍历算法，也就是只扫描新虚拟 DOM 树上的节点，判断是否需要更新，跳过不需要更新的节点，进一步减少了不必要的操作。此外，在虚拟 DOM 创建后，Vue 3 会缓存虚拟 DOM 节点的描述信息，以便于复用，这也会带来性能上的优势。同时，Vue 3 还引入了静态提升技术，在编译时将一些静态的节点及其子节点预先处理成 HTML 字符串，大大提升了渲染性能。\nVue 3 相对于 Vue 2 拥有更高效、更智能的 diff 算法，能够更好地避免不必要的操作，并提高了渲染性能")]),e._v(" "),v("p",[v("strong",[e._v("Vue3 为什么比 Vue2 快")])]),e._v(" "),v("ol",[v("li",[e._v("响应式系统优化：Vue3 引入了新的响应式系统，这个系统的设计让 Vue3 的渲染函数可以在编译时生成更少的代码，这也就意味着在运行时需要更少的代码来处理虚拟 DOM。这个新系统的一个重要改进就是提供了一种基于 Proxy 实现的响应式机制，这种机制为开发人员提供更加高效的 API，也减少了一些运行时代码。")]),e._v(" "),v("li",[e._v("编译优化：Vue3 的编译器对代码进行了优化，包括减少了部分注释、空白符和其他非必要字符的编译，同时也对编译后的代码进行了懒加载优化。")]),e._v(" "),v("li",[e._v("更快的虚拟 DOM：Vue3 对虚拟 DOM 进行了优化，使用了跟 React 类似的 Fiber 算法，这样可以更加高效地更新 DOM 节点，提高性能。")]),e._v(" "),v("li",[e._v("Composition API：Vue3 引入了 Composition API，这种 API 通过提供逻辑组合和重用的方法来提升代码的可读性和重用性。这种 API 不仅可以让 Vue3 应用更好地组织和维护业务逻辑，还可以让开发人员更加轻松地实现优化。")])]),e._v(" "),v("p",[v("strong",[e._v("vue3 编译做了哪一些优化")])]),e._v(" "),v("ol",[v("li",[v("p",[e._v("静态树提升： Vue 3.0 通过重写编译器，实现对静态节点（即不改变的节点）进行编译优化，使用 HoistStatic 功能将静态节点移动到 render 函数外部进行缓存，从而服务端渲染和提高前端渲染的性能。")])]),e._v(" "),v("li",[v("p",[e._v("Patch Flag：在 Vue 3.0 中，编译的生成 vnode 会根据节点 patch 的标记，只对需要重新渲染的数据进行响应式更新，不需要更新的数据不会重新渲染，从而大大提高了渲染性能。")])]),e._v(" "),v("li",[v("p",[e._v("静态属性提升：Vue3 中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用。免去了重复的创建操作，优化内存。\n没做静态提升之前，未参与更新的元素也在 render 函数内部，会重复创建阶段。\n做了静态提升后，未参与更新的元素，被放置在 render 函数外，每次渲染的时候只要取出即可。同时该元素会被打上静态标记值为-1，特殊标志是负整数表示永远不会用于 Diff。")])]),e._v(" "),v("li",[v("p",[e._v("事件监听缓存：默认情况下绑定事件行为会被视为动态绑定（没开启事件监听器缓存），所以每次都会去追踪它的变化。开启事件侦听器缓存后，没有了静态标记。也就是说下次 diff 算法的时候直接使用。")])]),e._v(" "),v("li",[v("p",[e._v("优化 Render function：Vue 3.0 的 compile 优化还包括：Render 函数的换行和缩进、Render 函数的条件折叠、Render 函数的常量折叠等等")])])])])}),[],!1,null,null,null);v.default=_.exports}}]);